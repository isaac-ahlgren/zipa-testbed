import os

from cryptography.hazmat.primitives import constant_time, hmac

from networking.network import *


def send_nonce_msg_to_device(
    connection,
    recieved_nonce_msg,
    derived_key,
    prederived_key_hash,
    nonce_byte_size,
    hash_func,
):
    """
    Sends a nonce message to a device, including a HMAC tag for verification.

    :param connection: The network connection object.
    :param received_nonce_msg: The nonce message received from the host.
    :param derived_key: The cryptographic key derived from an earlier exchange.
    :param prederived_key_hash: The hash of the key derived prior to this function.
    :param nonce_byte_size: The size of the nonce in bytes.
    :param hash_func: The hash function to use for HMAC.
    :returns: The nonce generated in this function.
    """
    nonce = os.urandom(nonce_byte_size)

    # Concatenate nonces together
    pd_hash_len = len(prederived_key_hash)
    recieved_nonce = recieved_nonce_msg[pd_hash_len : pd_hash_len + nonce_byte_size]
    concat_nonce = nonce + recieved_nonce

    # Create tag of Nonce
    mac = hmac.HMAC(derived_key, hash_func)
    mac.update(concat_nonce)
    tag = mac.finalize()

    # Construct nonce message
    nonce_msg = nonce + tag

    send_nonce_msg(connection, nonce_msg)

    return nonce


def send_nonce_msg_to_host(
    connection,
    prederived_key_hash,
    derived_key,
    nonce_byte_size,
    hash_func,
):
    """
    Sends a nonce message to the host, including a HMAC tag for verification.

    :param connection: The network connection object.
    :param prederived_key_hash: The hash of the pre-derived key.
    :param derived_key: The cryptographic key derived from an earlier exchange.
    :param nonce_byte_size: The size of the nonce in bytes.
    :param hash_func: The hash function to use for HMAC.
    :returns: The nonce generated in this function.
    """
    # Generate Nonce
    nonce = os.urandom(nonce_byte_size)

    # Create tag of Nonce
    mac = hmac.HMAC(derived_key, hash_func)
    mac.update(nonce)
    tag = mac.finalize()

    # Create key confirmation message
    nonce_msg = prederived_key_hash + nonce + tag

    send_nonce_msg(connection, nonce_msg)

    return nonce


def verify_mac_from_host(
    recieved_nonce_msg,
    generated_nonce,
    derived_key,
    nonce_byte_size,
    hash_func,
):
    """
    Verifies the HMAC tag received from the host.

    :param received_nonce_msg: The nonce message received from the host.
    :param generated_nonce: The nonce generated by the host, expected to match.
    :param derived_key: The cryptographic key used for HMAC.
    :param nonce_byte_size: The size of the nonce in bytes.
    :param hash_func: The hash function used for HMAC.
    :returns: True if the verification is successful, False otherwise.
    """
    success = False

    recieved_nonce = recieved_nonce_msg[0:nonce_byte_size]

    # Create tag of Nonce
    mac = hmac.HMAC(derived_key, hash_func)
    mac.update(recieved_nonce + generated_nonce)
    generated_tag = mac.finalize()

    recieved_tag = recieved_nonce_msg[nonce_byte_size:]
    if constant_time.bytes_eq(generated_tag, recieved_tag):
        success = True
    return success


def verify_mac_from_device(
    recieved_nonce_msg,
    derived_key,
    prederived_key_hash,
    nonce_byte_size,
    hash_func,
):
    """
    Verifies the HMAC tag received from a device.

    :param received_nonce_msg: The nonce message received from the device.
    :param derived_key: The cryptographic key used for HMAC.
    :param prederived_key_hash: The hash of the pre-derived key.
    :param nonce_byte_size: The size of the nonce in bytes.
    :param hash_func: The hash function used for HMAC.
    :returns: True if the verification is successful, False otherwise.
    """
    success = False

    # Retrieve nonce used by device
    pd_hash_len = len(prederived_key_hash)
    recieved_nonce = recieved_nonce_msg[pd_hash_len : pd_hash_len + nonce_byte_size]

    # Generate new MAC tag for the nonce with respect to the derived key
    mac = hmac.HMAC(derived_key, hash_func)
    mac.update(recieved_nonce)
    generated_tag = mac.finalize()

    recieved_tag = recieved_nonce_msg[pd_hash_len + nonce_byte_size :]
    if constant_time.bytes_eq(generated_tag, recieved_tag):
        success = True
    return success
