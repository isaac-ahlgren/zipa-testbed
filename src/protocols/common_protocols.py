import os
from typing import Any

from cryptography.hazmat.primitives import constant_time, hashes, hmac
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat

from networking.network import dh_exchange, dh_exchange_standby, send_nonce_msg


def send_nonce_msg_to_device(
    connection: Any,
    recieved_nonce_msg: bytes,
    derived_key: bytes,
    prederived_key_hash: bytes,
    nonce_byte_size: int,
    hash_func: hashes.HashAlgorithm,
) -> bytes:
    """
    Sends a nonce message to a device, including a HMAC tag for verification.

    :param connection: The network connection object.
    :param received_nonce_msg: The nonce message received from the host.
    :param derived_key: The cryptographic key derived from an earlier exchange.
    :param prederived_key_hash: The hash of the key derived prior to this function.
    :param nonce_byte_size: The size of the nonce in bytes.
    :param hash_func: The hash function to use for HMAC.
    :returns: The nonce generated in this function.
    """
    nonce = os.urandom(nonce_byte_size)

    # Concatenate nonces together
    pd_hash_len = len(prederived_key_hash)
    recieved_nonce = recieved_nonce_msg[pd_hash_len : pd_hash_len + nonce_byte_size]
    concat_nonce = nonce + recieved_nonce

    # Create tag of Nonce
    mac = hmac.HMAC(derived_key, hash_func)
    mac.update(concat_nonce)
    tag = mac.finalize()

    # Construct nonce message
    nonce_msg = nonce + tag

    send_nonce_msg(connection, nonce_msg)

    return nonce


def send_nonce_msg_to_host(
    connection: Any,
    prederived_key_hash: bytes,
    derived_key: bytes,
    nonce_byte_size: int,
    hash_func: hashes.HashAlgorithm,
) -> bytes:
    """
    Sends a nonce message to the host, including a HMAC tag for verification.

    :param connection: The network connection object.
    :param prederived_key_hash: The hash of the pre-derived key.
    :param derived_key: The cryptographic key derived from an earlier exchange.
    :param nonce_byte_size: The size of the nonce in bytes.
    :param hash_func: The hash function to use for HMAC.
    :returns: The nonce generated in this function.
    """
    # Generate Nonce
    nonce = os.urandom(nonce_byte_size)

    # Create tag of Nonce
    mac = hmac.HMAC(derived_key, hash_func)
    mac.update(nonce)
    tag = mac.finalize()

    # Create key confirmation message
    nonce_msg = prederived_key_hash + nonce + tag

    send_nonce_msg(connection, nonce_msg)

    return nonce


def verify_mac_from_host(
    recieved_nonce_msg: bytes,
    generated_nonce: bytes,
    derived_key: bytes,
    nonce_byte_size: int,
    hash_func: hashes.HashAlgorithm,
) -> bool:
    """
    Verifies the HMAC tag received from the host.

    :param received_nonce_msg: The nonce message received from the host.
    :param generated_nonce: The nonce generated by the host, expected to match.
    :param derived_key: The cryptographic key used for HMAC.
    :param nonce_byte_size: The size of the nonce in bytes.
    :param hash_func: The hash function used for HMAC.
    :returns: True if the verification is successful, False otherwise.
    """
    success = False

    recieved_nonce = recieved_nonce_msg[0:nonce_byte_size]

    # Create tag of Nonce
    mac = hmac.HMAC(derived_key, hash_func)
    mac.update(recieved_nonce + generated_nonce)
    generated_tag = mac.finalize()

    recieved_tag = recieved_nonce_msg[nonce_byte_size:]
    if constant_time.bytes_eq(generated_tag, recieved_tag):
        success = True
    return success


def verify_mac_from_device(
    recieved_nonce_msg: bytes,
    derived_key: bytes,
    prederived_key_hash: bytes,
    nonce_byte_size: int,
    hash_func: hashes.HashAlgorithm,
) -> bool:
    """
    Verifies the HMAC tag received from a device.

    :param received_nonce_msg: The nonce message received from the device.
    :param derived_key: The cryptographic key used for HMAC.
    :param prederived_key_hash: The hash of the pre-derived key.
    :param nonce_byte_size: The size of the nonce in bytes.
    :param hash_func: The hash function used for HMAC.
    :returns: True if the verification is successful, False otherwise.
    """
    success = False

    # Retrieve nonce used by device
    pd_hash_len = len(prederived_key_hash)
    recieved_nonce = recieved_nonce_msg[pd_hash_len : pd_hash_len + nonce_byte_size]

    # Generate new MAC tag for the nonce with respect to the derived key
    mac = hmac.HMAC(derived_key, hash_func)
    mac.update(recieved_nonce)
    generated_tag = mac.finalize()

    recieved_tag = recieved_nonce_msg[pd_hash_len + nonce_byte_size :]
    if constant_time.bytes_eq(generated_tag, recieved_tag):
        success = True
    return success


def diffie_hellman(
    connection: Any, ec_curve: Any, timeout: int, verbose: bool = True
) -> bytes:
    """
    Performs the Diffie-Hellman key exchange over a given socket to securely generate a shared secret.

    :param socket: The socket object used for the exchange.
    :return: The derived shared key as a byte string.
    """
    # Generate initial private key for Diffie-Helman
    initial_private_key = ec.generate_private_key(ec_curve)

    public_key = initial_private_key.public_key().public_bytes(
        Encoding.X962, PublicFormat.CompressedPoint
    )

    # Send initial key for Diffie-Helman
    if verbose:
        print("Send DH public key\n")

    dh_exchange(connection, public_key)

    # Recieve other devices key
    if verbose:
        print("Waiting for DH public key\n")

    other_public_key_bytes = dh_exchange_standby(connection, timeout)

    if other_public_key_bytes is None:
        if verbose:
            print("No initial key for Diffie-Helman recieved - early exit\n")
        return

    other_public_key = ec.EllipticCurvePublicKey.from_encoded_point(
        ec_curve, other_public_key_bytes
    )

    # Shared key generated
    shared_key = initial_private_key.exchange(ec.ECDH(), other_public_key)

    return shared_key
